%\documentclass[3p,12pt,authoryear]{elsarticle}
\documentclass[3p,12pt]{elsarticle}

\let\counterwithout\relax
\let\counterwithin\relax
%\usepackage{natbib}
%\usepackage{apacite}
\usepackage[colorlinks=true,citecolor=blue,linkcolor=blue]{hyperref}
\usepackage{amsmath,amssymb}
\usepackage{epsfig}  
\usepackage{graphicx}               % Standard graphics package  
\usepackage{url}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{color}
\usepackage{listings}

\usepackage{titlesec}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\usepackage{tikz}
\usetikzlibrary{trees}

\tikzstyle{every node}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[dashed,draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]

\usepackage{chngcntr}
\counterwithin{figure}{section}

\titleclass{\subsubsubsection}{straight}[\subsection]
\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered

\titleformat{\subsubsubsection}
  {\normalfont\normalsize\itshape}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\bra}[1]{\ensuremath{\left\langle#1\right|}}
\newcommand{\ket}[1]{\ensuremath{\left|#1\right\rangle}}
\newcommand{\bracket}[2]{\ensuremath{\left\langle#1 \vphantom{#2}\right| \left. #2 \vphantom{#1}\right\rangle}}
\newcommand{\matrixel}[3]{\ensuremath{\left\langle #1 \vphantom{#2#3} \right| #2 \left| #3 \vphantom{#1#2} \right\rangle}}
\newcommand{\bls}{\begin{lstlisting}}
\newcommand{\els}{\end{lstlisting}}

\newcommand{\ttf}{\ttfamily}

\newcommand{\pa}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\p}[1]{\partial_{#1}}

\definecolor{mauve}{rgb}{1,0,1}
\definecolor{dkgreen}{rgb}{0,0.6,0}
% \definecolor{gray}{rgb}{0.5,0.5,0.5}
% \definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{language=C++,
%   aboveskip=3mm,
%   belowskip=3mm,
%   showstringspaces=false,
%   columns=flexible,
   basicstyle={\small\ttfamily},
%   numbers=none,
%   numberstyle=\tiny\color{gray},
   morekeywords={SU\_vector,string,Body,Track,marray,Basis},   
   keywordstyle=\color{blue},
   deletekeywords={const},
   keywords=[2]{const},
   keywordstyle={[2]\ttfamily\color{red}},
   deletekeywords={operator},
   keywords=[3]{operator},
   keywordstyle={[3]\ttfamily\color{dkgreen}},
   commentstyle=\color{dkgreen},
   stringstyle=\color{mauve},
%   breaklines=true,
%   breakatwhitespace=true
%   tabsize=3
}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\begin{document}

\begin{frontmatter}

\title{$\nu$-SQuIDS: A toolbox for neutrino oscillations\tnoteref{t1}}

\author[MIT]{Carlos A. Arg\"uelles}
\ead{caad@mit.edu}
\author[UB]{Jordi Salvado}
\ead{jsalvado@icc.ub.edu}
\author[UA]{Christopher N. Weaver}
\ead{chris.weaver@icecube.wisc.edu}
\address[MIT]{Massachusetts Institute of Technology, Cambridge, MA 02139, USA}
\address[UA]{Dept.~of Physics, University of Alberta, Edmonton,
  Alberta, Canada T6G 2E1} 
\address[UB]{Departament de F\'isica Qu\`antica i Astrof√≠sica and Institut de Ciencies del Cosmos,
Universitat de Barcelona, Diagonal 647, E-08028 Barcelona, Spain}

\tnotetext[t1]{The code can be found in \url{https://github.com/arguelles/nuSQuIDS}}
\journal{arXiv}
%\journal{Computer Physics Communications}

\begin{abstract}
The Neutrino Simple Quantum Integro-Differential Solver ($\nu$-SQuIDS)
is a C++ code based on SQuIDS that propagates an ensemble of neutrinos
through a given media. Neutrino oscillation calculations relevant to
current and next generation experiments are implemented. In doing so
we account for coherent and non-coherent neutrino interactions in
different media such as the Sun, Earth, Vacuum, or others.
The code has been design to be accurate and flexible, while at the
same time maintain good performance. It has a modular design that
allows the user to incorporate new physics in novel scenarios. 
\end{abstract}

\begin{keyword}
Neutrino oscillation, phenomenology, collective neutrino behavior, numerical techniques
\end{keyword}

\end{frontmatter}

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}
\newpage
\section{Introduction}
\label{sec:intro} 

In recent decades a plethora of evidence that neutrinos change
flavor as they propagate macroscopic distances due to the
non-alignment of their mass and flavor eigenstates has accumulated from
solar~\citep{Abe:2010hy, Borexino2014},
atmospheric~\citep{PhysRevD.91.072004,Richard:2015aua},
accelerator~\citep{PhysRevLett.112.181801,
  PhysRevD.93.051104,PhysRevLett.116.151806, PhysRevLett.110.251801}, and
reactor \citep{An:2013zwz,Abe:2015rcp, Kim:2016yvm} experiments.
Thanks to these remarkable
experimental results and related theoretical calculations the
  neutrino-mass induced flavor oscillation paradigm
\citep{Pontecorvo:1967fh,Gribov:1968kq,fukugita2003physics,
  Akhmedov:1999uz,Balantekin:2013kc, GonzalezGarcia:2007ib,Mohapatra:qv, Gouvea:2013fj}
has been firmly established and the three mixing angles, which
parametrize the lepton mixing matrix, together with the two squared-mass differences, have been measured to good precision\citep{Esteban:2016qun,deSalas:2017kay,Capozzi:2018ubv}. It is the task of on-going 
and future experiments to determine the neutrino mass ordering
and the CP-violating phase \citep{Hewett:2012et,
  Acciarri:2016crz,Aartsen:2014oha, Kouchner:2016pqa,DeRosa:2016ifc}. 
Also, the IceCube Neutrino Observatory has recently made precise measurements of the atmospheric
spectrum above 100 GeV allowing new physics
models to be constrained~\citep{Aartsen:2014gkd,TheIceCube:2016oqi}, where the Earth is no longer transparent to neutrinos~\citep{Donini:2018tsg}.
The identification of high-energy
extraterrestrial neutrinos \citep{ Aartsen:2014gkd, Aartsen:2015rwa}
has opened the possibility of exploring new physics at these energies as well
\citep{Arguelles:2015dca, Bustamante:2015waa, Baerwald:2012kc}. 

Matter effects play a fundamental role in the explanation of solar
neutrinos \citep{ Davis:1968cp,Bethe:1986ej}, which has motivated the study of new flavor
changing neutrino interactions \citep{Barger:1991ae, Roulet:1991sm, GonzalezGarcia:2011my,
  Gonzalez-Garcia:2013usa, Pospelov:2011dp, Kopp:2014nosterile,
  Maltoni:2015kca,Esteban:2018ppq}.
Even though most of the data can be explained in the standard three
neutrino framework, some puzzling anomalies still remain
\citep{LSND,Mention:2011rr,MiniBoone:2012dn,Aguilar-Arevalo:2018gpe,Alekseev:2016llm, Ko:2016owz, Ashenfelter:2018iov, Abreu:2018pxg, Dentler:2018sju}. These may be explained
by introducing new light neutrino states \citep{kopp2013sterile,
  Collin:2016rao, Abazajian:2012rf,Blennow:2018hto} and other new physics
\citep{Bai:2015ztj,PalomaresRuiz:2005vf,Gninenko:2011xa}.
Also, the interplay between cosmology and neutrino
oscillation has been widely studied in the literature
\citep{Bergstrom:2014fqa, Giusarma:2016phn,
  Dasgupta:2013la,Hernandez:2016kel,Arguelles:2016uwb,Song:2018zyl,Chu:2018gxk}. 
In counclusion, neutrinos are good proves to perform 
fundamental physics tests~\citep{Hewett:2012et,Aartsen:2017ibm,Mewes:2018cze,Barenboim:2017vlc}.

Tools are needed to accurately and reliably compute neutrino
propagation.
When the only effect of propagation is neutrino oscillations libraries such as {\ttf GLoBES}
\citep{Huber:2007ji}, {\ttf Prob3++} \citep{prob3pp, Calland:2013vaa},
and {\ttf nuCRAFT} \citep{Wallraff:2014vl} are
available. Unfortunately, when non-coherent interactions are 
important they are no longer applicable. Furthermore, the ability to
allow the user to incorporate new physics models or to change the
propagation medium is also limited. {\ttf nuSQuIDS} seeks to
address all of these problems by providing a highly customizable
package, while at the same time remaining numerically efficient.

The rest of the paper is organized as follows: in section
\ref{sec:theory} we review neutrino oscillation theory; in section
\ref{sec:benchmark} we show the use of the code in typical
scenarios; in section \ref{sec:performance} we show the performance of
the library; in section \ref{sec:tests} we describe the unit tests that
are provided with the library; in section \ref{sec:code} we describe
the main classes and structure of the code. Finally, section
\ref{sec:conclu} presents concluding remarks.

\section{Neutrino Oscillations}
\label{sec:theory} 
In this section we briefly review neutrino oscillations
using the density matrix formalism.
We can represent the state of a neutrino ensemble at an energy $E$
and position $x$ using the density matrix. In the weak-interaction flavor-eigenstate basis
$\{\ket{\nu_\alpha}\}$  it can be written as
\begin{equation}
\rho(E,x) = \sum_\alpha \phi_\alpha(E,x) \ket{\nu_\alpha}\bra{\nu_\alpha} , 
\label{eq:state}
\end{equation}
where $\phi_\alpha$ specifies the flux of flavor $\alpha$.
These eigenstates can be related with the mass eigenstates,  $\{ \ket{\nu_i}  \}$, by
\begin{equation}
\ket{\nu_\alpha} = \sum_i U^*_{\alpha i} \ket{\nu_i} ,
\label{eq:changebasis}
\end{equation}
where $U$ is a unitary matrix known as the Pontecorvo-Maki-Nakagawa-Sakata (PMNS)
matrix or neutral lepton mixing matrix. For antineutrinos the relation
is the same as in 
\eqref{eq:changebasis} with $U \to U^*$.
It is customary to parametrize $U$ as a product of complex rotations,
\begin{equation}
\label{eq:mixing}
U(\theta_{ij}\delta_{ij})=R_{N-1\, N} R_{N-2\, N} ... R_{45} R_{35} R_{25} R_{15}
R_{34} R_{24} R_{14} R_{23} R_{13} R_{12}, 
\end{equation}
determined by angles, $\{\theta_{ij}\}$, and phases, $\{ \delta_{ij}
\}$~\cite{SQUIDS}. When considering the standard three flavor paradigm
the following parametrization is often used
\begin{equation}
U
=
\begin{pmatrix}
c_{12} c_{13} & s_{12} c_{13} & s_{13} e^{-i\delta_{13}} \\ 
- s_{12} c_{23} - c_{12} s_{23} s_{13} e^{i\delta_{13}} & c_{12} c_{23} - s_{12} s_{23} s_{13} e^{i\delta_{13}} & s_{23} c_{13} \\
s_{12}s_{23} -c_{12}c_{23}s_{13}e^{i\delta_{13}} & - c_{12} s_{23} - s_{12} c_{23} s_{13} e^{i\delta_{13}} & c_{23} c_{13}
\end{pmatrix}
\,,
\label{eq:U}
\end{equation}
where $c_{ij} \equiv \cos \theta_{ij}$, $s_{ij} \equiv \sin \theta_{ij}$. In the
three flavor scenario we use the aforementioned parametrization (with
values from \citep{Esteban:2016qun} by default).
The neutrino ensemble propagation is
described by the following quantum Von Neumann equation \footnote{We set $c = \hbar = 1$.} 
\begin{equation}
\pa{\rho(E,x)}{x} = -i [ H (E,x), \rho(E,x) ].
\label{eq:schrodinger}
\end{equation}

In general, we can always split the Hamiltonian, $H$, into
time-dependent and time-independent parts. For neutrino oscillations
the following splitting is convenient,
\begin{equation}
H(E,x) = H_0(E)  + H_{1}(E,x) ,
\end{equation}
with,
\begin{subequations}
\label{eq:hamiltonian}
\begin{align}
H_0 (E) &= \frac{1}{2E} {\rm diag}( 0 , \Delta m^2_{21},\Delta m^2_{31},\Delta m^2_{41},...,\Delta m^2_{n1}) \label{eq:h0} ,\\
H_1 (E,x) &= \sqrt{2} G_F U^\dagger {\rm diag} ( N_e(x) -
N_{nuc}(x)/2, -N_{nuc}(x)/2, -N_{nuc}(x)/2 , 0,...,0 )U ,\label{eq:hi} 
\end{align}
\end{subequations}
where $n$ is the number of neutrino states; $G_F$ is the Fermi
constant; $N_e(x)$ and $N_{nuc}(x)$ are the electron and nucleon number
densities at position $x$; and $\Delta m^2_{i1}$ are the neutrino mass
square differences.
In writing these equations we have used the convention that the first
three flavor eigenstates corresponds to 
$\nu_e$, $\nu_\mu$, and $\nu_\tau$, while the rest are assumed to be
sterile neutrinos. $H_0$ arises from the neutrino kinetic
term, where as $H_1$ incorporates the matter potential induced by coherent
forward scattering~\citep{Mikheev:1986gs,Mikheev:1986wj,Wolfenstein:1977ue}. Notice that the matter
potential, $H_1$, given in \eqref{eq:hi} for neutrinos changes to
$-H_1^*$ for antineutrinos. 
Since the propagation due to $H_0$ can be solved analytically is
convenient to use the  so-called interaction picture. For an operator
$O(x)$ the interaction picture transformed
operator, $O_I(x)$ is defined as
\begin{equation}
O_I(x)=\exp(-iH_0x)O(x)\exp(iH_0x).
\end{equation}
The corresponding evolution equation  for the neutrino state is
\begin{equation}
\pa{\rho_I(E,x)}{x} = -i [ H_{1I} (E,x), \rho_I(E,x) ]~.
\label{eq:schrodinger_int}
\end{equation}

So far we have only incorporated vacuum oscillations and matter
effects through coherent interactions, but we now wish to extend this
formalism to incorporate noncoherent interactions and collective
neutrino behavior. In what follows we will remove the subindex $I$ and
assume that all operators, unless specified, are in the interaction picture. 
This problem has been extensively discussed in the literature,
\citep{Sigl:1992fn,Duan:2010tk,Strack:qd,Zhang:2013ay,
 Cirelli:mw,Blennow:2007tw,Arguelles:2012cf}, for definiteness we
follow the formalism and notation given in
\citep{Gonzalez-Garcia:2005xw}.
The neutrino (antineutrino), $\rho$ $(\bar\rho)$, kinetic equations are
\begin{subequations}
\begin{eqnarray}
\pa{\rho(E,x)}{x} &=& -i [ H_1 (E,x), \rho(E,x) ] - \left\{ \Gamma(E,x),
  \rho(E,x) \right\} + F\left[\rho,\bar\rho;E,x\right] ,\\
%
\pa{\bar\rho(E,x)}{x} &=& i [ H^*_1 (E,x), \bar\rho(E,x) ] - \left\{ \bar\Gamma(E,x),
  \rho(E,x) \right\} + \bar F\left[\rho,\bar\rho;E,x\right] ,
\end{eqnarray}
\end{subequations}
where $\Gamma$ and $\bar\Gamma$  are functions that incorporate the effect of attenuation due to
noncoherent interactions, and $F$ and $\bar F$  are  functionals on
$\rho$ and $\bar\rho$ that take into account interactions between
different energies for neutrinos and antineutrinos.

In {\ttf nuSQuIDS} the attenuation terms are
\begin{subequations}
\begin{eqnarray}
\Gamma(E,x) &=& \frac{1}{2} \sum_\alpha  \frac{\Pi_\alpha(E,x)}{
  \lambda^\alpha_{\rm NC}(E,x)+\lambda^\alpha_{\rm CC}(E,x)},\label{eq:gammarhoa} \\
%
\bar\Gamma(E,x) &=& \frac{1}{2} \sum_\alpha  \frac{\bar\Pi_\alpha(E,x)}{
  \bar\lambda^\alpha_{\rm NC}(E,x)+\bar\lambda^\alpha_{\rm CC}(E,x)
  + \bar\lambda^\alpha_{\rm GR}(E,x)}, \label{eq:gammarhob}
\end{eqnarray}
\end{subequations}
where $\Pi_\alpha(E,x)$ is the neutrino projector onto flavor $\alpha \in
\{e,\mu,\tau\}$, $\lambda^\alpha_{\rm CC}$ ($\lambda^\alpha_{\rm NC}$)
is the charged (neutral) current neutrino interaction length,
given by $(N_{nuc}(x)\sigma^\alpha_{\rm CC(NC)}(E))^{-1}$\citep{CooperSarkar:2011pa}, and
$\bar\lambda^e_{\rm GR}$ is the mean free path due to the Glashow
resonance $(N_{e}(x)\sigma^e_{\rm GR}(E))^{-1}$~\citep{Gandhi:1998ri}. Notice that we assume
the matter only contains electrons, protons, and neutrons,
i.e. $\bar\lambda^\mu_{\rm GR}=\bar\lambda^\tau_{\rm GR}=0$.
The other interaction terms are as follows
\begin{subequations}
  \begin{eqnarray}
    F\left[\rho,\bar\rho;E,x\right] &=& \sum_\alpha \Pi_\alpha(E,x)  \int_E^\infty  
    {\rm Tr}\left[\Pi_\alpha(E_{\nu_\alpha},x) \rho(E_{\nu_\alpha},x) \right]
    \frac{1}{\lambda^\alpha_{\rm NC}(E_{\nu_\alpha},x)} \pa{N^\alpha_{\rm
        NC}(E_{\nu_\alpha},E)}{E} dE_{\nu_\alpha}  \label{eq:intro} \nonumber\\
    &&  + \Pi_\tau (E,x) \int_E^\infty\int_{E_\tau}^\infty  
    {\rm Tr} \left[ \Pi_\tau(E_{\nu_\tau},x)
      \rho(E_{\nu_\tau},x)\right] \nonumber\\
    && \hspace{2cm} \times \frac{1}{\lambda^\tau_{\rm CC}(E_{\nu_\tau},x)}
    \pa{N^{\tau}_{\rm CC} (E_{\nu_\tau},E_\tau)}{E_\tau}
    \pa{N^{\rm all}_{\rm dec}
      (E_\tau,E)}{E}  dE_{\nu_\tau} dE_\tau  \nonumber \\
    &&  + \Big({\rm Br}_e \Pi_e (E,x)+{\rm
      Br}_\mu\Pi_\mu (E,x)\Big) \int_E^\infty\int_{E_\tau}^\infty  
    {\rm Tr} \left[
      \bar\Pi_\tau(E_{\bar\nu_\tau},x)
      \bar\rho(E_{\bar\nu_\tau},x)\right]\nonumber\\
    && \hspace{2cm} \times \frac{1}{\bar\lambda^\tau_{\rm CC} ( E_{\bar\nu_\tau},x)}
    \pa{\bar N^{\tau}_{\rm CC} (E_{\bar\nu_\tau},E_\tau)}{E_\tau}
    \pa{\bar N^{\rm lep}_{\rm dec}
      (E_\tau,E)}{E}  dE_{\bar\nu_\tau}
    dE_\tau 
    \label{eq:Fterm}
  \end{eqnarray}
  \begin{eqnarray}
    \bar F\left[\rho,\bar\rho;E,x\right] &=& \sum_\alpha \bar\Pi_\alpha(E,x)  \int_E^\infty  
    {\rm Tr}\left[\bar\Pi_\alpha(E_{\bar\nu_\alpha},x) \bar\rho(E_{\bar\nu_\alpha},x) \right]
    \frac{1}{\bar\lambda^\alpha_{\rm NC}(E_{\bar\nu_\alpha},x)} \pa{\bar N^\alpha_{\rm
        NC}(E_{\bar\nu_\alpha},E)}{E} dE_{\bar\nu_\alpha}  \label{eq:intro} \nonumber\\
    &&  + \bar\Pi_\tau (E,x) \int_E^\infty\int_{E_\tau}^\infty  
    {\rm Tr} \left[ \bar\Pi_\tau(E_{\bar\nu_\tau},x)
      \bar\rho(E_{\bar\nu_\tau},x)\right] \nonumber\\
    && \hspace{2cm} \times \frac{1}{\bar\lambda^\tau_{\rm CC}(E_{\nu_\tau},x)}
    \pa{\bar N^{\tau}_{\rm CC} (E_{\bar\nu_\tau},E_\tau)}{E_\tau}
    \pa{\bar N^{\rm all}_{\rm dec}
      (E_\tau,E)}{E}  dE_{\bar\nu_\tau} dE_\tau  \nonumber \\
    &&  + \Big({\rm Br}_e \bar\Pi_e (E,x)+{\rm
      Br}_\mu\bar\Pi_\mu (E,x)\Big) \int_E^\infty\int_{E_\tau}^\infty  
    {\rm Tr} \left[
      \Pi_\tau(E_{\nu_\tau},x)
      \rho(E_{\nu_\tau},x)\right]\nonumber\\
    && \hspace{2cm} \times \frac{1}{\lambda^\tau_{\rm CC} ( E_{\nu_\tau},x)}
    \pa{N^{\tau}_{\rm CC} (E_{\nu_\tau},E_\tau)}{E_\tau}
    \pa{N^{\rm lep}_{\rm dec}
      (E_\tau,E)}{E}  dE_{\nu_\tau}
    dE_\tau \label{eq:antiFterm}\\ 
    && + \left(\sum_\alpha \bar\Pi_\alpha(E,x)\right) \int_E^\infty {\rm Tr}
    \left[\bar\Pi(E_{\bar\nu_e},x)\bar\rho(E_{\bar\nu_e},x)\right]
    \frac{1}{\bar\lambda_{\rm GR} ( E_{\bar\nu_e},x)}
    \pa{\bar N^e_{\rm GR} (E_{\bar\nu_e},E)}{E}
    d E_{\bar\nu_e}\nonumber
  \end{eqnarray}
\end{subequations}
where ${\rm Br}_\alpha$ is the $\tau$ branching ratio to $\nu_\alpha$,
\begin{subequations}
  \begin{eqnarray}
    \pa{N^{\alpha}_{\rm CC (NC)}
      (E_{\nu_\alpha},E_\alpha)}{E_\alpha}&=&\frac{1}{\sigma^\alpha_{\rm
        CC(NC)} (E_{\nu_\alpha})} \pa{\sigma^\alpha_{\rm
        CC(NC)} (E_{\nu_\alpha},E_\alpha)}{E_\alpha}, \\
    \pa{\bar N^{e}_{\rm GR}
      (E_{\bar\nu_e},E_e)}{E_e}&=&\frac{1}{\bar\sigma^e_{\rm
        GR} (E_{\bar\nu_e})} \pa{\bar\sigma^e_{\rm
        GR} (E_{\bar\nu_e},E_e)}{E_e},
  \end{eqnarray}
\end{subequations}
are the charged current, neutral current, and Glashow resonance
interaction. The $\tau$ decay distribution~\citep{Dutta:2000jv} in all modes and leptonic
modes are
\begin{eqnarray}
\pa{N^{\rm lep}_{\rm
    dec}(E_\tau,E)}{E}&=&\frac{1}{{\tilde\Gamma_{\rm lep}}^\tau(E_\tau)}
\pa{\tilde\Gamma_{\rm lep}^\tau(E_{\tau},E)}{E}, \\
\pa{N^{\rm all}_{\rm
    dec}(E_\tau,E)}{E}&=&\frac{1}{{\tilde\Gamma_{\rm all}}^\tau(E_\tau)}
\pa{\tilde\Gamma_{\rm all}^\tau(E_{\tau},E)}{E}, 
\end{eqnarray}
where $\tilde \Gamma^\tau(E_{\tau})=\frac{E_{\tau}}{m_\tau}\tau_\tau$,
in which $m_\tau$ is the $\tau$ mass and $\tau_\tau$ is the $\tau$
lifetime, ``all'' and ``lep'' indicate the all and leptonic $\tau$
decay modes, respectively.

The first term in \eqref{eq:Fterm} and \eqref{eq:antiFterm} accounts for
neutrino re-injection at lower energies coming from
\eqref{eq:gammarhoa} and \eqref{eq:gammarhob} due to neutral current
interaction.
The second and third term is the injection due to the $\tau$ decay
in to $\nu_\tau$ and in the other flavors in the leptonic case: this
is known as tau-regeneration. It is important to note that the latter
terms couple the propagation of neutrinos and antineutrinos.
Finally, the last term in \eqref{eq:antiFterm} accounts for the
neutrinos produced in the Glashow resonance due to $W^-$ decay.


%%ejemplos de codigo
%\input{examples.tex}
\section{Examples}
\label{sec:examples}
To help the user to apply the library in concrete scenarios we provide
a set o examples. These examples are located in different sub-folders inside a folder
called {\ttf examples}. An specific example can be compiled using the
makefile by running {\ttf make examples example\_name}, omitting the
name compiles all the examples. 
Some of the examples contain a {\ttf Gnuplot} script to plot the output file.

\subsection{Single energy \textnormal{({\ttf examples/Single\_energy})}}
\label{sec:single}
This example illustrates the use of the simplified mode to compute the
propagation of the neutrinos for a single energy. 

In the following we will go though the main file of the example.
First we construct the nusquids object using the signature that
requires only the number of flavors and to specify if its
neutrino or antineutrino type.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1]
  nuSQUIDS nus(3,neutrino);
\end{lstlisting}

In the following function we set the value of the oscillation paramters, we put
the value for the mixing angles in radians, the value for the mass
square difference in electron-volt squared and a value for the CP
phase in radians.
In order to do so we use the {\ttf Set\_MixingAngle} member function
whose first two arguments are the indices of the rotation  starting
from zero. Similarly for the CP phase function.
In the case of the square mass difference we use the first argument is
the mass eigenvalue index and the second the value.
 
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  nus.Set_MixingAngle(0,1,0.563942);
  nus.Set_MixingAngle(0,2,0.154085);
  nus.Set_MixingAngle(1,2,0.785398);

  nus.Set_SquareMassDifference(1,7.65e-05);
  nus.Set_SquareMassDifference(2,0.00247);

  nus.Set_CPPhase(0,2,0.0);
\end{lstlisting}

We declare a structure that contains all the physical units and
constants we will need. 
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  squids::Const units;
\end{lstlisting}

This line sets the energy of the neutrino to be propagate.
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  nus.Set_E(10.0*units.GeV);
\end{lstlisting}

In these lines we define the medium in which we are going to propagate
the neutrino. In this example we will use the earth and specify the
path by the zenith angle, see~\ref{sec:body} for more details.

These are separate objects in the code, in this example we construct
an atmospheric earth object, {\ttf earth\_atm}, which contains the
earth geometry and density. We also construct a trajectory in the
earth for a zenith angle {\ttf phi}, {\ttf earth\_atm\_track}. Finally
we set these objects to nuSQuIDS.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  double phi = acos(-1.0);
  std::shared_ptr<EarthAtm> earth_atm = std::make_shared<EarthAtm>();
  std::shared_ptr<EarthAtm::Track> earth_atm_track =
  std::make_shared<EarthAtm::Track>(phi);
  nus.Set_Body(earth_atm);
  nus.Set_Track(earth_atm_track);
\end{lstlisting}

Now we set the initial neutrino flavor. In this example we start with
a muon neutrino represented by an {\ttf marray} of length {\ttf
  \{3\}}, corresponding to the number of flavors, and with value given
by {\ttf\{0,1,0\}}.


\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  marray<double,1> ini_state({3},{0,1,0});
  nus.Set_initial_state(ini_state,flavor);
\end{lstlisting}

We set the numerical error for the GSL differential equation solver.
The parameters and errors are defined as in the standard GSL libraries.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  nus.Set_rel_error(1.0e-20);
  nus.Set_abs_error(1.0e-20);
\end{lstlisting}

Finally we show the result before and after propagation. The
propagation is done by calling the function {\ttf nus.EvolveState()}

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  std::cout << ``In state'' << std::endl;
  for (double EE : nus.GetERange()){
    std::cout << EE/units.GeV << `` ``;
    for(int i = 0; i < 3; i++){
      std::cout << nus.EvalFlavor(i) << `` ``;
    }
    std::cout << std::endl;
  }
  // We do the calculation                                                                                  
  nus.EvolveState();
  
  // Output the result                                                                                 
  std::cout << ``Out state'' << std::endl;
  for (double EE : nus.GetERange()){
    std::cout << EE/units.GeV << `` ``;
    for(int i = 0; i < 3; i++){
      std::cout << nus.EvalFlavor(i) << `` ``;
    }
    std::cout << std::endl;
  }
\end{lstlisting}


\subsection{Multiple Energy \textnormal{({\ttf examples/Multiple\_energy})}}
This is a more realistic example where we consider an ensemble of
neutrinos in an energy range. With this setup
we can model the neutrino energy and flavor changes.
For example interactions such as charged and neutral current.
In the following we describe the code for the example.

As before we construct the Const object to have a set of useful physical parameters.
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  squids::Const units;
\end{lstlisting}

In the following we allow the possibility of choosing to compute
the propagation for three active neutrinos or three active and one sterile.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true, label = ex:sin1,firstnumber=last]
  std::cout << "(3) Three Active Neutrinos, " << "(4) 3+1 Three Active and One Sterile Neutrino" << std::endl;
  unsigned int numneu;
  std::cin >>numneu;
  if( not(numneu==3 || numneu==4)){
    throw std::runtime_error("Only (3) or (4) are valid options");
  }
\end{lstlisting}

In the next line, we construct the nuSQUIDS object. For the
multiple energy constructor we need to provide the following arguments:
list of neutrino energy nodes
(\lstinline[columns=fixed,breaklines=true]{logspace(1.*units.GeV,1.e4*units.GeV,200)}),
number of neutrino flavors ({\ttf numneu}= 3 or 4), neutrino or
anti-neutrino type ({\ttf neutrino}), and non-coherent scattering
interactions ({\ttf false}). 
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,
  label = ex:sin1,firstnumber=last]
  nuSQUIDS nus(logspace(1.*units.GeV,1.e4*units.GeV,200),numneu,neutrino,false);
\end{lstlisting}

As in the single energy mode we must define the body and the path
where neutrinos will propagate.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,
  label = ex:sin1,firstnumber=last]
  double phi = acos(-1.);
  std::shared_ptr<EarthAtm> earth_atm = std::make_shared<EarthAtm>();
  std::shared_ptr<EarthAtm::Track> track_atm = std::make_shared<EarthAtm::Track>(phi);
  nus.Set_Body(earth_atm);
  nus.Set_Track(track_atm);
\end{lstlisting}

We also set the neutrino oscillation parameters and if a sterile
neutrino is considered we set it's parameters to $\theta_{24}=0.1$ and
$\Delta m_{41}^2=0.1{\rm eV}^2$.
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.Set_MixingAngle(0,1,0.563942);
  nus.Set_MixingAngle(0,2,0.154085);
  nus.Set_MixingAngle(1,2,0.785398);
  nus.Set_SquareMassDifference(1,7.65e-05);
  nus.Set_SquareMassDifference(2,0.00247);

  if(numneu==4){
    // sterile neutrino parameters
    nus.Set_SquareMassDifference(3,0.1);
    nus.Set_MixingAngle(1,3,0.1);
  }
\end{lstlisting}

Next we set some of the integration parameters: the maximum
step for the evolution,  the GSL stepper algorithm (all the steppers in
the GSL libraries can be used), maximum relative and absolute error.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.Set_h_max( 500.0*units.km );
  nus.Set_GSL_step(gsl_odeiv2_step_rk4);
  nus.Set_rel_error(1.0e-5);
  nus.Set_abs_error(1.0e-5);
\end{lstlisting}

We set to {\ttf true} the progress bar options in order to display the
progress of the propagation.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.Set_ProgressBar(true);
\end{lstlisting}

We can ask nuSQUIDS to give back the array containing the values of
the energy nodes. We use this here to fill a multiple array with the initial
state of the system; in this case a $E^{-2}$ power-law for the muon
flavor and zero for the others.
 
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  marray<double,1> E_range = nus.GetERange();
  marray<double,2> inistate{E_range.size(),numneu};
  double N0 = 1.0e18;
  for ( int i = 0 ; i < inistate.extent(0); i++){
      for ( int k = 0; k < inistate.extent(1); k ++){
        inistate[i][k] = (k == 1) ? N0*pow(E_range[i],-2) : 0.0;
      }
  }
  nus.Set_initial_state(inistate,flavor);
\end{lstlisting}

Here we evolve the state.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.EvolveState();
\end{lstlisting}

Finally we write the propagated fluxes in a file called {\ttf
  flux\_flavor.txt} and after that we ask to run the plotting script.

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  std::ofstream file("fluxes_flavor.txt");
  
  int Nen =1000;
  double lEmin=0;
  double lEmax=4;
  
  file << "# log10(E) E flux_i fluxRatio_i . . . ." << std::endl;
  for(double lE=lEmin; lE<lEmax; lE+=(lEmax-lEmin)/(double)Nen){
    double E=pow(10.0,lE)*units.GeV;
    file << lE << " " << E << " ";
    for(int fl=0; fl<numneu; fl++){
      file << " " <<  nus.EvalFlavor(fl, E) << " " <<  nus.EvalFlavor(fl, E)/(N0*pow(E,-2));
    }
    file << std::endl;
  }
  file.close();
  std::string plt;
  std::cout << std::endl <<  "Done! " << std::endl <<
  "  Do you want to run the gnuplot script? yes/no" << std::endl;
  std::cin >> plt;
  if(plt=="yes" || plt=="y")
  return system("./plot.plt");
\end{lstlisting}


\begin{figure}[h!]
  \label{fig:multimode}
  \centering
  \includegraphics[width=0.7\textwidth]{fig/Multiplot.eps} 
  \caption{Output for the multiple energy mode with sterile neutrino (3+1)} 
\end{figure}
 
In fig.\ref{fig:multimode} we show the results of running this example
for the case with sterile neutrino.

\subsection{Read and Write \textnormal{({\ttf examples/HDF5\_Write\_Read})}}
\label{sec:readwrite}
In this example we illustrate the use of the functions to
read and write {\ttf HDF5} files. The file contains the full
information of the system: all settings, body, track (including
current position in the track), and the density matrix at each node.
This serialization allows to save the system
in the middle of a complex propagation and read it later to continue
the calculation. Saving the system using this and loading it from
the file restores the system to the saved state allowing the user to
compute any quantum mechanical observable.

This example is based upon the multiple energy example but
split in two parts. The first part computes the evolution and saves the
state of the system ({\ttf write.cpp}). The second reads the
state,  extract the flavor fluxes, and  prints them to a file ({\ttf
  read.cpp}).

In the following we describe lines that are relevant for reading and writing.

In the file {\ttf write.cpp} we save the system before and after the
evolution.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  nus.WriteStateHDF5(``./initial_state.hdf5'');
  nus.EvolveState();
  nus.WriteStateHDF5(``./final_state.hdf5'');
\end{lstlisting}

And in order to recover that in the {\ttf read.cpp} file we use the
constructor that takes as an argument the name of the file.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  nuSQUIDS inus(``./initial_state.hdf5'');
  nuSQUIDS fnus(``./final_state.hdf5''); 
\end{lstlisting}


\subsection{Construction and use of bodies \textnormal{({\ttf
      examples/Bodies})}}
\label{sec:body}
One of the main classes in the nuSQUIDS library are the body and the
track. These two do not have defaults in the code and always needs to
be specified.
In this example we show how to use the objects already implemented in
the library and also how to create some objects from the classes
already defined.

The folder {\ttf examples/Bodies/} contains a new body an track
definitions in the files {\ttf exBody.h} and {\ttf exBody.cpp}.
It also contains the file {\ttf main.cpp} whose main function 
uses all the already existing objects in nuSQUIDS and the new objects
of these examples.


\subsubsection{Construct a derived body}

Here is an example of how to define a derived object of the EarthAtm
body. In this simple case the object is just an earth model with some
parameters that weight the relative densities in the different layers
of the Earth's inner core, outer core, and mantel.

In order to implement it we suggest to do it inside the {\ttf nusquids}
namespace. We define a new class called {\ttf EarthMod}, which is a derived class of {\ttf
  EarthAtm}. Because of this the new class will have all the properties,
values, and functions of the parent class. 
\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1]
namespace nusquids{

class EarthMod: public EarthAtm{
public:
\end{lstlisting}

Our object constructors requires the following inputs:
based earth model file name ({\ttf earthmodel}), inner core weight
({\ttf frho1}), outer core weight ({\ttf frho2}), mantle weight ({\ttf
  frho3}).

\begin{lstlisting}[frame=leftline, numbers = left,breaklines=true,label = ex:sin1,firstnumber=last]
  EarthMod(std::string earthmodel, double frho1, double frho2, double
  frho3);
\end{lstlisting}
The function {\ttf Mod} allows to change the parameters ones the
object is already defined.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  void  Mod(double frho1, double frho2, double frho3);
};

\end{lstlisting}

The implementation of the functions that set the density arrays with
the modified values are given in the files {\ttf exBody.cpp}.

\subsubsection{Use of the bodies}

In this part we will describe what is implemented in {\ttf
  main.cpp}.
This file defines a nuSQUIDS object and sets different bodies and
tracks. For each of these it evolves the system and shows the
probabilities in the screen.
For simplicity we use the single energy mode sec.~\ref{sec:single}, but the use of the body
and track would be the same for the multiple energy case.

First we construct the nuSQUIDS object for three neutrinos, then we set the
oscillation parameters and the neutrino energy.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  nuSQUIDS nus(3,neutrino);
  nus.Set_MixingAngle(0,1,0.563942);
  nus.Set_MixingAngle(0,2,0.154085);
  nus.Set_MixingAngle(1,2,0.785398);
  nus.Set_SquareMassDifference(1,7.65e-05);
  nus.Set_SquareMassDifference(2,0.00247);
  nus.Set_CPPhase(0,2,0.0);
  squids::Const units;
  nus.Set_E(10.0*units.GeV);
\end{lstlisting}

\begin{enumerate}
\item {\ttf Earth}

The first example is the {\ttf Earth} body. In this case the track is
parametrized by the baseline of the experiment. Here we define the
body and track. For the track we need to specify the initial and final
position as well as the baseline. 
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  double baseline = 500.0*units.km;
  std::shared_ptr<Earth> earth = std::make_shared<Earth>();
  std::shared_ptr<Earth::Track> earth_track = std::make_shared<Earth::Track>(0.0,baseline,baseline);
\end{lstlisting}
And we set the Body and Track to the nuSQuIDS object.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.Set_Body(earth);
  nus.Set_Track(earth_track);
\end{lstlisting}

We first set the initial state of the system and print the state in
the screen.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  marray<double,1> ini_state({3},{0,1,0});
  nus.Set_initial_state(ini_state,flavor);
  // Lets print out the initial state
  std::cout << "In state" << std::endl;
  for (double EE : nus.GetERange()){
    std::cout << EE/units.GeV << " ";
    for(int i = 0; i < 3; i++){
      std::cout << nus.EvalFlavor(i) << " ";
    }
    std::cout << std::endl;
  }
\end{lstlisting}
We set the numerical error and maximum step for the GSL integrator.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.Set_h_max( 200.0*units.km );
  nus.Set_rel_error(1.0e-12);
  nus.Set_abs_error(1.0e-12);
\end{lstlisting}

Finally we evolve the state and print in the screen the final state of
the system.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.EvolveState();
  std::cout << "Out state" << std::endl;
  for (double EE : nus.GetERange()){
    std::cout << EE/units.GeV << " ";
    for(int i = 0; i < 3; i++){
      std::cout << nus.EvalFlavor(i) << " ";
    }
    std::cout << std::endl;
  }
\end{lstlisting}
These last steps in the code are the same in all the bodies examples and we
are omitting this for the next cases.

\item {\ttf EarthAtm}

In this example we use the {\ttf EarthAtm} body. The
track is defined by the zenith angle of the trajectory.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  double phi = acos(-1.0);
  std::shared_ptr<EarthAtm> earth_atm = std::make_shared<EarthAtm>();
  std::shared_ptr<EarthAtm::Track> earth_atm_track = std::make_shared<EarthAtm::Track>(phi);

  nus.Set_Body(earth_atm);
  nus.Set_Track(earth_atm_track);
\end{lstlisting}

\item {\ttf earth\_mod}

  In this case we use the modified earth object.
  As before the track is deffined by the zenith angle of
  the trajectory. In the constructor we set all the weight to $0.1$.
  Finally we set the body an track to nuSQUIDS.
  
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  double phi = acos(-1.0);
  std::shared_ptr<EarthMod> earth_mod = std::make_shared<EarthMod>(0.1,0.1,0.1);
  std::shared_ptr<EarthMod::Track> earth_mod_track = std::make_shared<EarthMod::Track>(phi);  

  nus.Set_Body(earth_mod);
  nus.Set_Track(earth_mod_track);
\end{lstlisting}


\item {\ttf VariableDensity}

In this case we use the variable density body and a track of $200{\rm km}$
First we define the density, position, and electron fraction arrays
with the corresponding values.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  int N=40;

  std::vector<double> x_arr(N);
  std::vector<double> density_arr(N);
  std::vector<double> ye_arr(N);

  double size = 1000.0*units.km;
  for(int i = 0; i < N; i++){
    x_arr[i] = size*(i/(double)N);
    density_arr[i] = fabs(cos((double)i));
    ye_arr[i] = fabs(sin((double)i));
  }
\end{lstlisting}

Now we construct the body and the track. The constructor for the
variable density takes as an input the position, density, and electron
fraction vectors. Finally, like before, we set the body and the track in nuSQUIDS.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]

  std::shared_ptr<VariableDensity> vardens = std::make_shared<VariableDensity>(x_arr,density_arr,ye_arr);
  std::shared_ptr<VariableDensity::Track> track_vardens = std::make_shared<VariableDensity::Track>(0.0,200.0*units.km);

  nus.Set_Body(vardens);
  nus.Set_Track(track_vardens);
\end{lstlisting}

\item {\ttf Vacuum}

This is a trivial case where the density and electron fraction are
zero. We only need to give the baseline as an argument to construct
the track. In this example we set the baseline to $500{\rm km}$.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  double baseline_2 = 500.0*units.km;
  std::shared_ptr<Vacuum> vacuum = std::make_shared<Vacuum>();
  std::shared_ptr<Vacuum::Track> track_vac = std::make_shared<Vacuum::Track>(baseline_2);
  
  nus.Set_Body(vacuum);
  nus.Set_Track(track_vac);
\end{lstlisting}

\item {\ttf ConstantDensity}

In the case of constant density an analytic approximation can be
used to propagate the neutrinos if non-coherent interactions are
disabled in the construction of the nuSQuIDS object. The full
Hamiltonian of the system is diagonalized and exponentiated. 

We set the density to $100{\rm g/cm}^3$, the electron fraction to $0.3$, and the
baseline to $500{\rm km}$.
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]

  double density = 100.0;
  double ye = 0.3;
  std::shared_ptr<ConstantDensity> constdens = std::make_shared<ConstantDensity>(density,ye);
  double baseline_3 = 500.0*units.km;
  std::shared_ptr<ConstantDensity::Track> track_constdens =   std::make_shared<ConstantDensity::Track>(0.0,baseline_3);

  nus.Set_Body(constdens);
  nus.Set_Track(track_constdens);
\end{lstlisting}
\end{enumerate}

\subsection{Cross Sections \textnormal{({\ttf
      examples/Xsections})}}

One of the important features of nuSQuIDS is the possibility of handling in a
consistent way the non-coherent interactions with the oscillation
behavior. The physical quantity that encodes how often this scattering
interaction happen between the neutrinos and the media is the cross
section.
nuSQuIDS it has implemented two kind of interactions: charge and
neutral current. In the case of charge current we have in to account
the neutrinos produced by the decay of short lived charged particles
such as $\tau$ and $W^\pm$. For the neutral current we always include
the outgoing neutrino.
Other particles produced in the interactions such as hadrons or long
lived charged leptons are ignored along the evolution.
This information is organized and stored in the cross-section class.
This class requires the user to provide the total cross-section for
each flavor and current in units of cm$^2$. It also requires to
specify the single differential neutrinos cross sections with respect to
the outgoing neutrino energy in units of cm$^2$/GeV. 

nuSQuIDS includes by default deep inelastic neutrino nucleon
cross-sections as well as neutrino electron
cross-sections~\citep{Gandhi:1998ri, CooperSarkar:2011pa}.

In this example construct a new cross section object to be used by
nuSQuIDS instead of the default one.
Every cross section must be a class of {\ttf NeutrinoCrossSections}
and implement at least two member functions:
{\ttf SingleDifferentialCrossSection} and {\ttf TotalCrossSection}.


\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  class LinearCrossSections : public NeutrinoCrossSections {
    private:
    const squids::Const units;
    const double GF = 1.16639e-23; // eV^-2
    const double mp = 938.272e6; // proton mass eV
    const double CC_to_NC; // proportion of CC to NC which goes from 0 to 1.
    public :
    LinearCrossSections(double CC_to_NC):CC_to_NC(CC_to_NC){assert( CC_to_NC <= 1.0  && CC_to_NC >= 0.0 );}
    LinearCrossSections():LinearCrossSections(0.5){}
    double TotalCrossSection(double Enu, NeutrinoFlavor flavor, NeutrinoType neutype, Current current) const override;
    double SingleDifferentialCrossSection(double E1, double E2, NeutrinoFlavor flavor, NeutrinoType neutype, Current current) const override;
  };  
 
\end{lstlisting}

In this example we use a toy total cross section that scales linearly with
the neutrino energy and the corresponding differential cross sections
linear in the outgoing neutrino energy; see implementation in {\ttf
  exCross.cpp}. We also allow to change the proportion charge to
neutral current at the construction of the object.


We construct two cross section objects: one with only charge current  interactions
{\ttf ncs\_cc} and another with only neutral current {\ttf
  ncs\_nc}. Then we construct the corresponding nuSQuIDS objects {\ttf nus\_cc} and {\ttf nus\_nc}.
We also disable neutrino oscillations in this example by means of the
option {\ttf Set\_IncludeOscillations(false)}.

\begin{lstlisting}[frame=leftline, numbers =  
  left,breaklines=true,label = ex:sin1]
  std::shared_ptr<NeutrinoCrossSections> ncs_cc=std::make_shared<LinearCrossSections>(0.0);
  std::shared_ptr<NeutrinoCrossSections> ncs_nc=std::make_shared<LinearCrossSections>(1.0);

  nuSQUIDS nus_cc(logspace(Emin,Emax,200),numneu,neutrino,true,ncs_cc);
  nus_cc.Set_IncludeOscillations(false);
  nuSQUIDS nus_nc(logspace(Emin,Emax,200),numneu,neutrino,true,ncs_nc);
  nus_nc.Set_IncludeOscillations(false);
\end{lstlisting}


We can see the final to initial flux ratios for both cases in fig~\ref{fig:crossext}.

\begin{figure}[h!]
  \label{fig:crossext}
  \centering
  \includegraphics[width=0.7\textwidth]{fig/crossext.eps} 
  \caption{Final to initial flux ratio as a function of the logarithm
    of the neutrino energy for the example toy cross sections with
    only charged current and only neutral current.} 
\end{figure}


\subsection{Constant density multiple layers \textnormal{({\ttf
      examples/Constant\_density\_layers})}}
Since the constant density allows us to do very fast computation using
the diagonalization of the full Hamiltonian here we show an example
where we concatenate the evolution of the neutrinos through different
layers of constant density.

We construct three different layers: first $100{\rm km}$ in
vacuum, second $50{\rm km}$ in matter with density $3.5{\rm g/cm}^3$ and
 electron fraction $0.5$, and finally $200{\rm km}$ in matter with
 density $10{\rm g/cm}^3$ and electron fraction $0.1$.
 
\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  const double layer_1 = 100.*units.km;
  std::shared_ptr<Vacuum> vacuum = std::make_shared<Vacuum>();
  std::shared_ptr<Vacuum::Track> track_env0 = std::make_shared<Vacuum::Track>(layer_1);

  const double layer_2 = 50.*units.km;
  std::shared_ptr<ConstantDensity> constdens_env1 = std::make_shared<ConstantDensity>(3.5,0.5); 
  std::shared_ptr<ConstantDensity::Track> track_env1 = std::make_shared<ConstantDensity::Track>(layer_2);

  const double layer_3 = 200.*units.km;
  std::shared_ptr<ConstantDensity> constdens_env2 = std::make_shared<ConstantDensity>(10.,0.1);
  std::shared_ptr<ConstantDensity::Track> track_env2 = std::make_shared<ConstantDensity::Track>(layer_3);
\end{lstlisting}

Now in order to evolve the system we set the corresponding body
and track and evolve every layer.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  nus.Set_Body(vacuum);
  nus.Set_Track(track_env0);
  nus.EvolveState();

  nus.Set_Body(constdens_env1);
  nus.Set_Track(track_env1);
  nus.EvolveState();

  nus.Set_Body(constdens_env2);
  nus.Set_Track(track_env2);
  nus.EvolveState();
\end{lstlisting}

Finally, we write the output for the different flavor fluxes in a text file.


\subsection{BSM extension: Non-Standard  Interaction (NSI) \textnormal{({\ttf
      examples/NSI})}}
\label{sec:NSI}
In this example we illustrate how to construct a derived class of
nuSQuIDS including a new physics term. This procedure is similar to
other new physics setups~\ref{sec:LV}.

The implementation of {\ttf nuSQUIDSNSI} class is in {\ttf NSI.h}.
We will go trough the implementation to see what needs to be
added to be base class.

First, we declare the NSI matter potential as a {\ttf SU\_vector}
called {\ttf NSI}. By default nuSQuIDS  works in the interaction
picture, thus every term we add to the hamiltonian has to be properly
evolved with $H_0$. Since $H_0$ depends on the energy to do this in
every node. For optimization we will compute and store the evolved NSI
term in a vector of {\ttf SU\_vector} objects called {\ttf NSI\_evol}.

The {\ttf HI\_prefactor} contains all the numerical factors multiplying the
operator and {\ttf epsilon\_mutau} is the strength of the NSI $\mu$-$\tau$ 
non-diagonal component. Notice that we set all other NSI
contributions to zero.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
class nuSQUIDSNSI: public nuSQUIDS {
  private:
    squids::SU_vector NSI;
    std::vector<squids::SU_vector> NSI_evol;
    std::unique_ptr<double[]> hiBuffer;
    double HI_prefactor;
    // nsi parameters
    double epsilon_mutau;

\end{lstlisting}

As we said before we need to compute the NSI operator in the
interaction picture prior to adding it to the r.h.s. of the
differential equation. We compute this for every energy node in the
{\ttf AddToPreDerive} function. This function is called inside the
{\ttf PreDerive} function before evaluating the derivatives to allow
the user to pre-compute terms used in the derivative.
The evolution of the NSI term by $H_0$ is done by the {\ttf
  SU\_vector::Evolve} member. This function is optimized and performs
the evolution of the operator analytically.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
    void AddToPreDerive(double x){
      for(int ei = 0; ei < ne; ei++){
        NSI_evol[ei] = NSI.Evolve(H0_array[ei],(x-Get_t_initial()));
      }
    }
\end{lstlisting}

The following auxiliary member functions allow {\ttf nuSQUIDSNSI} to
save the new physics parameters into the hdf5 files when the
{\ttf WriteStateHDF5} is called~\ref{sec:readwrite}.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
    void AddToReadHDF5(hid_t hdf5_loc_id){
      // here we read the new parameters now saved in the HDF5 file
      hid_t nsi = H5Gopen(hdf5_loc_id, "nsi", H5P_DEFAULT);
      H5LTget_attribute_double(hdf5_loc_id,"nsi","mu_tau" ,&epsilon_mutau);
      H5Gclose(nsi);
    }

    void AddToWriteHDF5(hid_t hdf5_loc_id) const {
      // here we write the new parameters to be saved in the HDF5 file
      H5Gcreate(hdf5_loc_id, "nsi", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      H5LTset_attribute_double(hdf5_loc_id, "nsi","mu_tau",&epsilon_mutau, 1);
    }
\end{lstlisting}

Here we overload the {\ttf HI} function where we return the nuSQuIDS
matter potential plus the new NSI contribution.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
    squids::SU_vector HI(unsigned int ei,unsigned int index_rho) const{
      double CC = HI_prefactor*body->density(*track)*body->ye(*track);

      squids::SU_vector potential(nsun,hiBuffer.get());

      potential = (3.0*CC)*NSI_evol[ei];

      if ((index_rho == 0 and NT==both) or NT==neutrino){
          return nuSQUIDS::HI(ei,index_rho) + potential;
      } else if ((index_rho == 1 and NT==both) or NT==antineutrino){
          return nuSQUIDS::HI(ei,index_rho) + (-1.0)*std::move(potential);
      } else{
          throw std::runtime_error("nuSQUIDS::HI : unknown particle or antiparticle");
      }
    }
\end{lstlisting}

The constructor first calls the
nuSQUIDS constructor and then sets the oscillation
paramters and the NSI operator.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  public:
  nuSQUIDSNSI(double epsilon_mutau, marray<double,1> Erange,
              int numneu, NeutrinoType NT, bool iinteraction,
              double th01=0.563, double th02=0.154, double th12=0.785):
              nuSQUIDS(Erange,numneu,NT,iinteraction),
	      hiBuffer(new double[nsun*nsun]),
              epsilon_mutau(epsilon_mutau)
  {
    assert(numneu == 3);
    // defining a complex matrix M which will contain our flavor
    // violating flavor structure.
    gsl_matrix_complex * M = gsl_matrix_complex_calloc(3,3);
    gsl_complex c {{ epsilon_mutau , 0.0 }};
    gsl_matrix_complex_set(M,2,1,c);
    gsl_matrix_complex_set(M,1,2,gsl_complex_conjugate(c));
    
    NSI = squids::SU_vector(M);
    
    Set_MixingAngle(0,1,th01);
    Set_MixingAngle(0,2,th02);
    Set_MixingAngle(1,2,th12);
    
    // rotate to mass reprentation
    NSI.RotateToB1(params);
    NSI_evol.resize(ne);
    for(int ei = 0; ei < ne; ei++){
      NSI_evol[ei] = squids::SU_vector(nsun);
    }
    gsl_matrix_complex_free(M);
    
    HI_prefactor = params.sqrt2*params.GF*params.Na*pow(params.cm,-3);
  }
\end{lstlisting}

The next function sets the value of {\ttf epsilon\_mutau} changing the
 {\ttf SU\_vector NSI} object accordingly. We construct the {\ttf
   SU\_vector} operator as a complex GSL matrix that represents the
 operator in the flavor basis. Since nuSQuIDS solves the propagation
 in the basis where $H_0$ is diagonal, i.e. the mass basis, we rotate
 the NSI operator to the mass basis by calling {\ttf RotateToB1}.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  void Set_mutau(double eps){
    gsl_matrix_complex * M = gsl_matrix_complex_calloc(3,3);
    gsl_complex c {{ epsilon_mutau , 0.0 }};
    gsl_matrix_complex_set(M,2,1,c);
    gsl_matrix_complex_set(M,1,2,gsl_complex_conjugate(c));
    NSI = squids::SU_vector(M);    
    NSI.RotateToB1(params);
    gsl_matrix_complex_free(M);
  }
\end{lstlisting}

In {\ttf main.cpp} we use the new NSI in a
multiple energy mode. In order to compare the oscillation
probabilities with and without NSI we construct two instances {\ttf
  nuSQUIDSNSI} with {\ttf  epsilon\_mutau=0} and {\ttf
  epsilon\_mutau=1e-2}. 

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  double eps_mutau=1.0e-2;
  nuSQUIDSNSI nus(eps_mutau,logspace(Emin,Emax,200),numneu,antineutrino,false);
  nuSQUIDSNSI nus_zero(0.0,logspace(Emin,Emax,200),numneu,antineutrino,false);
\end{lstlisting}

In the next lines we propagate both objects and print both
fluxes in a file.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  nus.EvolveState();
  nus_zero.EvolveState();

  int Nen =1000;
  double lEmin=log10(Emin);
  double lEmax=log10(Emax);
  
  std::ofstream file("fluxes_flavor.txt");

  file << "# log10(E) E flux_NSI_i flux_noNSI_i . . . ." << std::endl;
  for(double lE=lEmin; lE<lEmax; lE+=(lEmax-lEmin)/(double)Nen){
    double E=pow(10.0,lE);
    file << lE << " " << E << " ";
    for(int fl=0; fl<numneu; fl++){
      file << " " <<  nus.EvalFlavor(fl, E) << " " <<  nus_zero.EvalFlavor(fl, E);
    }
    file << std::endl;
  }
\end{lstlisting}

In the folder there is a script that allows to plot the output text
file.


\subsection{BSM extension: Lorentz Violation \textnormal{({\ttf
      examples/LV})}}
The Lorentz symmetry is a well established property of space-time.
As a fundamental symmetry it should be tested and neutrino
oscillations prove part of the parameter space.

The example is technically the same as the non-standard interactions,
but we add a couple of features illustrate good practices.

As before the new term is added in to {\ttf HI}. For this particular
physics case the effect is positive for neutrinos and negative for
antineutrinos. This can be implemented using the integer {\ttf irho}
which labels neutrinos with $0$ and antineutrinos with $1$.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  squids:: SU_vector HI(unsigned int ie,unsigned int irho) const {
    squids::SU_vector potential = nuSQUIDS::HI(ie, irho);
    double sign = 1;
    if ((irho == 1 and NT==both) or NT==antineutrino){
      // antineutrino matter potential flips sign
      sign*=(-1);
    }
    // ===== HERE WE ADD THE NEW PHYSICS =====
    potential += sign*pow(E_range[ie],n_)*LVP_evol[ie]; 
    // ===== HERE WE ADD THE NEW PHYSICS =====
    return potential;
  }
\end{lstlisting}

The parameters of the Lorentz violating term is set by the function
{\ttf Set\_LV\_OpMatrix}. In doing that the oscillation parameters are
used to rotate to the mass basis. Therefore any change done in the
oscillation parameters after setting the LV term will be inconsistent.
In order to prevent inconsistencies we overload the function that sets
the mixing parameters {\ttf Set\_MixingAngle} and the phases {\ttf
  Set\_CPPhase} turning the label {\ttf lv\_parameters\_set} to {\ttf
  false} and forcing the need to call {\ttf Set\_LV\_OpMatrix} again.
This enforces the order of the set functions calls.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
    void Set_MixingAngle(unsigned int i, unsigned int j,double angle){
      nuSQUIDS::Set_MixingAngle(i,j,angle);
      lv_parameters_set = false;
    }

    void Set_CPPhase(unsigned int i, unsigned int j,double angle){
      nuSQUIDS::Set_CPPhase(i,j,angle);
      lv_parameters_set = false;
    }
\end{lstlisting}


\subsection{Atmospheric Mode: Standard \textnormal{({\ttf
      examples/Atm\_default})}}
\label{sec:atmexample}
In this example we show how to use the atmospheric mode. This mode is
a compact way to treat a set of nuSQUIDS objects distributed in
zenith.
This allows us to propagate the energy-zenith dependent atmospheric
neutrino flux thought the Earth.

First, we construct the nuSQUIDSAtm object. The parameters of the
constructors are the list of cosine of the zenith angle values ({\ttf
  linspace(czmin,czmax,40)}) and the following arguments as the
multiple energy constructor.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1]
  double Emin=1.e1*units.GeV;
  double Emax=1.e6*units.GeV;
  double czmin=-1;
  double czmax=0;

  nuSQUIDSAtm<> nus_atm(linspace(czmin,czmax,40),logspace(Emin,Emax,100),numneu,both,interactions);
\end{lstlisting}

In this case the initial state is marray of rank four with double values.  
The first index is for the zenith, the second for the energy, the
third for particle type (neutrino or antineutrino), and the last one
for the neutrino flavor.

In this example we fill the multi-dimensional array with the initial state of the
system where the function {\ttf flux\_function} would be the corresponding
atmospheric flux.

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  marray<double,4> inistate{nus_atm.GetNumCos(),nus_atm.GetNumE(),2,numneu};
  std::fill(inistate.begin(),inistate.end(),0);
  for ( int ci = 0 ; ci < nus_atm.GetNumCos(); ci++){
    for ( int ei = 0 ; ei < nus_atm.GetNumE(); ei++){
      for ( int rho = 0; rho < 2; rho ++ ){
        for (int flv = 0; flv < numneu; flv++){
          inistate[ci][ei][rho][flv] = (flv == 1) ? flux_function(e_range[ei], cz_range[ci]) : 0.0;//set 1 only to the muon flavor
        }
      }
    }
  }
  nus_atm.Set_initial_state(inistate,flavor);
\end{lstlisting}

To evolve the full state we call as always {\ttf EvolveState}. 

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
nus_atm.EvolveState();
\end{lstlisting}

Finally, we evaluate as print the flux in a file. The
atmospheric mode has an interpolation implemented that allows to
evaluate the flux at any flavor, energy, and cosine-zenith. See \ref{sec:atm}
for more details.


\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  int Nen=700;
  int Ncz=100;
  double lEmin=log10(Emin);
  double lEmax=log10(Emax);;

  file << "# log10(E) cos(zenith) E flux_i . . . ." << std::endl;
  for(double cz=czmin;cz<czmax;cz+=(czmax-czmin)/(double)Ncz){
    for(double lE=lEmin; lE<lEmax; lE+=(lEmax-lEmin)/(double)Nen){
      double E=pow(10.0,lE);
      file << lE << " " << cz << " " << E;
      for(int fl=0; fl<numneu; fl++){
	file << " " <<  nus_atm.EvalFlavor(fl,cz, E);
      }
      file << std::endl;
    }
    file << std::endl;
  }
\end{lstlisting}


\subsection{Atmospheric mode: BSM \textnormal{({\ttf examples/Atm\_BSM})}}
\label{sec:atmBSM}
The atmospheric mode is implemented such  that it can be used with any
nuSQUIDS derived class. In this example we use the atmospheric mode
with the NSI nuSQUIDS extension shown in the NSI example~\ref{sec:NSI}.

In the folder we include a copy of the NSI header file {\ttf NSI.h}.
The main file is essentially the same as the atmospheric default mode
example with the following changes.
The class type template argument is the nuSQuIDS derived class. The
constructor takes list of cosine zenith angle values and then the
derived class constructor arguments. 

\begin{lstlisting}[frame=leftline, numbers =
  left,breaklines=true,label = ex:sin1,firstnumber=last]
  double epsilon_mutau=1e-2;
  nuSQUIDSAtm<nuSQUIDSNSI> nus_atm(linspace(czmin,czmax,40),epsilon_mutau,logspace(Emin,Emax,100),numneu,both,true);
\end{lstlisting}

\section{Performance and precision}
\label{sec:performance} 

\section{Test suite}
\label{sec:tests}
A test suit is provided with the library to warranty the right
performance in different systems or after any modification of the
code. All the test are located in the folder {\ttf nuSQuIDS/test}
And they can be run using the provided script {\ttf test/run\_tests}.
A single test can be run adding the name as and argument to the script
command.
In the following we list the tests that are provided with a brief
description of what they test.

\begin{itemize}
  
\item {\ttf test/vacuum\_osc\_prob.test}
  
  Tests that propagation with only oscillation of
  neutrinos in vacuum is equal to the analytic solution.

\item {\ttf test/constant\_density\_osc\_prob.test}
  
  Tests that propagation with only oscillation of
  neutrinos in constant density is equal to the analytic solution.

\item {\ttf test/constant\_opacity.test}
  
  Tests that propagation on a constant density with no oscillation and
  neglecting regeneration from neutral current or tau decay matches
  the expected expnential behavior.
  
\item {\ttf test/constant\_opacity\_with\_nc.test}
  
  Tests that propagation on a constant density with no oscillation 
  matches an independent numerical solution.  
  
\item {\ttf test/atmospheric\_he.test}

  Tests that the high-energy propagation without oscillation of
  neutrinos from the atmosphere does not give negative or {\ttf nan} values.

\item {\ttf test/atmospheric\_osc.test}
  
  Tests that propagation with only oscillation of
  neutrinos from the atmosphere does not give negative or {\ttf nan}
  values.
  
\item {\ttf test/body\_serialization.test}
  
  It checks that writing a body in to the hdf5 file and reading it
  back does not alter the body.  

\item {\ttf test/cross\_section\_consistency.test}
  
  Check that the differential cross section add with numerical error
  the total cross section.
  
\item {\ttf test/earth\_osc\_prob.test}
  
  Test that three and four neutrinos oscillation probability over a
  1000km baseline in multiple and single energy modes matches with the
  numerical error to reference independent calculation.
  
\item {\ttf test/glashow\_resonance.test}
  
  Checks that Glashow resonance integrated differential cross-section
  matches with the total cross-section and that is used while propagating. 
  
\item {\ttf test/hdf5\_atm\_in\_out.test}
  
  It checks that writing a nuSQuIDs atmospheric object into a hdf5 file and reading it
  back does not alter the object and recovers all the properties.

  
\item {\ttf test/hdf5\_in\_out.test}
  
  It checks that writing a nuSQuIDs object into a hdf5 file and reading it
  back does not alter the object and recovers all the properties.

\item {\ttf test/move\_assig.test}
  
  Checks that constructor of a nuSQuIDS object from an rvalue nuSQuIDS object works.
  
\item {\ttf test/mul\_energy\_constructor.test}
  
  Checks that the multiple energy constructor works.
  
\item {\ttf test/time\_reversal.test}
  
  Checks that propagating a neutrino and propagating again backwards
  in time returns to the original state.
  
\item {\ttf test/tools\_integrator.test}
  
  Checks that the provided one dimensional integrate function works
  with in the numerical error.
  
\item {\ttf test/track\_concatenate\_hdf5.test}
  
  Checks that propagating by concatenating a series of tracks in
  vacuum and writing and reading that state a every step is the same
  as propagating with a single track with the total length. 
  
  
\item {\ttf test/track\_concatenate.test}
  
  Checks that propagating by concatenating a series of tracks in
  vacuum is the same as propagating with a single track with the total length. 
  

\end{itemize}


\section{Description of the code} 
\label{sec:code} 

$\nu$-SQuIDS is a {\ttf C++} code built using the SQuIDS
framework \citep{SQUIDS}. It is designed to propagate neutrinos
through media while taking into account flavor oscillations and
noncoherent interactions. 

In order to allow the user to compute simple oscillation probabilities
for a single energy the code has a simplified mode.
In this mode the neutrino energy is fixed and only coherent interactions
are treated.
In this case, only Eq. \eqref{eq:schrodinger} is relevant for the
neutrino propagation, and the {\ttf nuSQuIDS} class implements {\ttf
  SQuIDS::H0} as in Eq. \eqref{eq:h0} and {\ttf SQuIDS::HI} as given
in Eq. \eqref{eq:hi}. 

In the default mode a statistical ensemble of neutrinos is
considered. The ensemble is described by means of a set of {\ttf
  SU\_vector} objects located at fixed  energy nodes spaced over the
energy region under consideration. Besides defining {\ttf SQuIDS::H0}
and {\ttf SQuIDS::HI}, as in the simplified single energy mode, the
following functions are also defined: {\ttf SQuIDS::GammaRho} by
equations \eqref{eq:gammarhoa} and \eqref{eq:gammarhob}, and {\ttf
  SQuIDS::InteractionsRho} in equations \eqref{eq:Fterm} and
\eqref{eq:antiFterm}. Furthermore, in the latter equation
\eqref{eq:antiFterm} $\tau$-regeneration is implemented assuming
instantaneous $\tau$ decay.

While the {\ttf nuSQuIDS} class implements all the necessary
differential equations, one must also specify the neutrino propagation
environment, propagation trajectory, and the relevant cross sections.  
When interactions are considered the {\ttf nuSQuIDS} instance
will automatically construct appropriate {\ttf NeutrinoCrossSections}
and {\ttf TauDecaySpectra} objects to evaluate cross sections and
$\tau$ physics respectively, however, the user can also replace these
default versions if desired. On the other hand, the user must
explicitly specify the neutrino propagation medium and trajectory
through relevant specialization of {\ttf Body} and {\ttf Body::Track}.
Several implementations of {\ttf Body} and {\ttf Track} covering
common physics cases are supplied with the library. 

Finally, {\ttf nuSQuIDS} provides a set functions to evaluate the
neutrino ensemble flavor and mass composition as well as the
capability to store the system state in an HDF5 \citep{folk1999hdf5}
file for later use.

% TODO: mention setting mixing parameters used for propagation

\input{body_track.tex}
\input{cross_section_tau_decay.tex}
\input{nusquids_class.tex}
\input{nusquidsatm_class.tex}

% TODO: section describing space and time complexity, benchmarks

\section{Python Interface}

As the particle physics community has transition from {\ttfamily FORTRAN} to {\ttfamily C++} based Monte Carlos, it is also a current trent to be able to interface particle physics software with high level interpreted languages such as {\ttfamily Mathematica}, {\ttfamily R}, and {\ttfamily Python}. Of these languages we have decided to implement bindings with Python due to the well developed {\ttfamily C++}-{\ttfamily Python} bindings given by the {\ttfamily Boost} library. In later version of this software we may incorporate interfaces to other high level languages; though, note, that in particular {\ttfamily Mathematica} architecture is not object oriented and bindings to other languages only exist in {\ttfamily C} and {\ttfamily FORTRAN}.

\subsection{Installation}

In order to install nuSQuIDS python bindings additional libraries are required, namely, {\ttfamily Boost.Python} ($\ge1.54$) and {\ttfamily Python.numpy} ($\ge1.7$). Upon installing these new prerequisites you can run the following commands to install the bindings

% TODO: this won't actually build or install the bindings
% We don't even have an install target for the bindings; we might need/want to add one

\begin{lstlisting}[language=Bash]
./config --with-python-bindings
make && make install
\end{lstlisting}

After successful installation you can import the python bindings in the following manner

\begin{lstlisting}[language=Python]
import nuSQUIDSpy as nsq
\end{lstlisting}
where here we have introduce the alias {\ttfamily nsq} for the nuSQuIDS python module. We can further extend the
capabilities of nuSQuIDS in {\ttfamily Python} by means of the the {\ttfamily nuSQUIDSTools} python module. When 
this module is loaded the nuSQuIDS functions and objects get overloaded with python only functionalities. In order to enable this, after loading the {\ttfamily nuSQUIDSpy} module, do

\begin{lstlisting}[language=Python]
import nuSQUIDSTools
\end{lstlisting}


\subsection{Description of the interface}



\subsection{Examples}

\section{Conclusions \& Acknowledgements} 
\label{sec:conclu} 

\bibliographystyle{plainnat}
%\bibliographystyle{apacite}
%\bibliographystyle{elsarticle-harv}

\bibliography{nusquids}

\end{document}

