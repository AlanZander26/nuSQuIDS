\subsection{nuSQUIDS}

This object is an specialization of the {\ttf SQUIDS} class~\citep{SQUIDS} that implements the
differential equations as described in Sec.~\ref{sec:theory}. In
particular, it is used to specify the propagation {\ttf Body} and its
associated {\ttf Track}. Moreover, it uses the {\ttf
  NeutrinoCrossSections} and {\ttf TauDecaySpectra} in order to
evaluate the neutrino cross sections and $\tau$ decay spectra; the
latter is only used then {\it $\tau$} regeneration is
enabled. Furthermore, it enables the user to modify the neutrino
oscillation parameters as well as the differential equation numerical
precision. Finally, it also has the capability to create and read HDF5
files that store the program results and configuration. 

\subsubsection{Constructors}

\begin{itemize}
\item Default constructor.
  \begin{lstlisting}
    nuSQUIDS();
  \end{lstlisting}
\item Move constructor.
  \begin{lstlisting}
    nuSQUIDS(nuSQUIDS&&);
  \end{lstlisting}
Constructs a {\ttf nuSQUIDS} object from an r-value reference.  
\item Single energy mode constructor.
  \begin{lstlisting}
    nuSQUIDS(unsigned int numneu, NeutrinoType NT);
  \end{lstlisting}
This constructor and initialization function initializes {\ttfamily nuSQUIDS} in the
single energy mode. {\ttfamily numneu} specifies the number of
neutrino flavors which can go from two to six, while {\ttfamily NT} can be
set to  {\ttfamily neutrino} or {\ttfamily antineutrino}. 
\item Multiple energy mode constructor.
  \begin{lstlisting}
    nuSQUIDS(marray<double,1> E_vector,
    unsigned int numneu,NeutrinoType NT = both,
    bool iinteraction = false,
    std::shared_ptr<NeutrinoCrossSections> ncs = nullptr)
  \end{lstlisting}
This constructor and initialization function initializes {\ttfamily nuSQUIDS} in the
multiple energy mode. We need to provide the following arguments:
list of neutrino energy nodes
(\lstinline[columns=fixed,breaklines=true]{E_vector}),
number of neutrino flavors ({\ttf numneu}), neutrino or
anti-neutrino type ({\ttf NT}),  non-coherent scattering
interactions ({\ttf iinteraction}), and neutrino cross section object
pointer ({\ttf ncs}).  

\item Constructing from a $\nu$SQuIDS-HDF5 file
  \begin{lstlisting}
    nuSQUIDS(std::string hdf5_filename, std::string grp = "/",
    std::shared_ptr<InteractionStructure> int_struct = nullptr)
  \end{lstlisting}
This constructor initializes {\ttfamily nuSQUIDS} from a 
previously generated $\nu$SQuIDS HDF5 file. {\ttfamily filepath} must
specify the full path of the HDF5 file, {\ttfamily grp} specifies the
location on the HDF5 file structure where the object will be saved (by default
it will be saved on the {\ttfamily root} of the HDF5 file), and {\ttf
  int\_struct} can specify the cross-section object instead of loading it from
the file.
\end{itemize}

\subsubsection{Functions}

\textbf{Functions to evaluate flavor and mass composition}

\begin{itemize}
\item Flavor composition evaluator (single energy mode)
  \begin{lstlisting}
    double EvalFlavor(unsigned int flv) const;
  \end{lstlisting}
Returns the content a given neutrino flavor specified by {\ttfamily
  flv} ({\ttfamily 0 = $e$}, {\ttfamily 1 = $\mu$}, {\ttfamily 2 =
  $\tau$}, ...). This function can only be use in the single energy
mode. 
\item Flavor composition evaluator (multiple energy mode)
  \begin{lstlisting}
    double EvalFlavorAtNode(unsigned int flv, unsigned int ie, 
                            unsigned int rho=0) const;
    double EvalFlavor(unsigned int flv, double enu,
                      unsigned int rho=0) const;
    double EvalFlavor(unsigned int flv,double enu,
                      unsigned int rho,double scale,
                      std::vector<bool>& avr) const;
  \end{lstlisting}
{\ttfamily EvalFlavorAtNode} returns the content a given neutrino
flavor specified by {\ttfamily flv} ({\ttfamily 0 = $e$}, {\ttfamily 1
  = $\mu$}, {\ttfamily 2 = $\tau$, ...}) at an energy node {\ttfamily
  ie}. Furthermore, {\ttfamily EvalFlavor} returns the approximate
content of a given flavor for a specific neutrino energy  {\ttf enu}
by interpolating in the interaction basis. In each function, when
considering  {\ttf  NT = both}, the parameter {\ttf rho} toggles
between {\ttf neutrino (0)} and {\ttf antineutrino (1)}.
The last function gets two additional arguments: an {\ttf scale} such
that all $H_0$ induced oscillation frequencies larger than this scale
will be averaged and a vector of booleans which entries will be set to
true if the corresponding oscillations frequencies have been averaged
out.


\item Mass composition evaluator (single energy mode)
  \begin{lstlisting}
    double EvalMass(unsigned int eig) const;
  \end{lstlisting}
Returns the content a given neutrino mass eigenstate specified by {\ttfamily eig} ({\ttfamily 0 = $\nu_1$}, {\ttfamily 1 = $\nu_2$}, {\ttfamily 2 = $\nu_3$, ...}). This function can only be use in the  single energy mode.
\item Mass composition evaluator (multiple energy mode)
  \begin{lstlisting}
    double EvalMassAtNode(unsigned int eig, unsigned int ie,
                           unsigned int rho=0) const;
    double EvalMass(unsigned int eig, double enu,
                     unsigned int rho=0) const;
    double EvalMass(unsigned int flv,double enu,
                    unsigned int rho,double scale,
                    std::vector<bool>& avr) const;
  \end{lstlisting}
{\ttfamily EvalMassAtNode} returns the content a given neutrino mass
eigenstate specified by {\ttfamily eig} ({\ttfamily 0 = $\nu_1$},
{\ttfamily 1 = $\nu_2$}, {\ttfamily 2 = $\nu_3$, ...}) at an energy
node {\ttfamily ie}. Furthermore, {\ttfamily EvalMass} returns the
approximate content of a given mass eigenstate for a specific neutrino
energy  {\ttf enu} by interpolating in the interaction basis. In each
function, when considering  {\ttf  NT = both}, the parameter {\ttf
  rho} toggles between {\ttf neutrino (0)} and {\ttf antineutrino
  (1)}. The last function gets two additional arguments: an {\ttf scale} such
that all $H_0$ induced oscillation frequencies larger than this scale
will be averaged and a vector of booleans which entries will be set to
true if the corresponding oscillations frequencies have been averaged
out.
\end{itemize}

\textbf{Functions to evolve the neutrino ensemble}

\begin{itemize}
\item Evolve state
  \begin{lstlisting}
    void EvolveState();
  \end{lstlisting}
Once the neutrino propagation problem has been setup this function
evolves the neutrino state from its initial position to its final
position specified by the {\ttfamily track}. 
\end{itemize}

\textbf{Functions obtain properties of the nuSQUIDS object as well as the state}

\begin{itemize}
\item Get energy nodes values
  \begin{lstlisting}
    marray<double,1> GetERange() const;
  \end{lstlisting}
  Returns a one dimensional array containing the energy nodes
  positions given in eV. 
  \item Get number of energy nodes
  \begin{lstlisting}
    unsigned int GetNumE() const;
  \end{lstlisting}
  Returns the number of energy nodes.
  \item Get number neutrino flavors
  \begin{lstlisting}
    unsigned int GetNumNeu() const;
  \end{lstlisting}
  Returns the number of neutrino flavors.
  \item Get Hamiltonian at current position
  \begin{lstlisting}
    SU_vector GetHamiltonian(unsigned int ie, 
                             unsigned int rho = 0);
  \end{lstlisting}
  Returns the {\ttf SU\_vector} that represents the (anti)neutrino
  Hamiltonian at the current position, at a given energy node {\ttf
    ie}, and  {\ttf rho} specifies whether the neutrino or antineutrino.
  \item Get the state of the system 
  \begin{lstlisting}
      const squids::SU_vector& GetState(unsigned int ei,unsigned int rho = 0) const;
  \end{lstlisting}
  Returns the {\ttf SU\_vector} that represents the (anti)neutrino state at given energy node {\ttf ie}. 
  Furthermore, {\tt rho} specifies whether the neutrino or antineutrino state is returned.
  \item Get the flavor projector
  \begin{lstlisting}
    SU_vector GetFlavorProj(unsigned int ie, unsigned int rho = 0) const;
  \end{lstlisting}
  Returns a {\ttf SU\_vector} that represents the flavor projector for the energy node {\ttf ie} and 
  {\ttf rho} specifies if neutrinos or antineutrinos are requested.
  \item Get the mass projector
  \begin{lstlisting}
    SU_vector GetMassProj(unsigned int ie, unsigned int rho = 0) const;
  \end{lstlisting}
  Returns a {\ttf SU\_vector} that represents the mass projector for the energy node {\ttf ie} and 
  {\ttf rho} specifies if neutrinos or antineutrinos are requested.
  \item Get {\ttfamily Body}
  \begin{lstlisting}
    std::shared_ptr<Body> GetBody() const;
  \end{lstlisting}
  Returns the {\ttf Body} instance currently stored in the {\ttf nuSQUIDS} object.
  \item Get {\ttfamily Track}
  \begin{lstlisting}
    std::shared_ptr<Track> GetTrack() const;
  \end{lstlisting}
  Returns the {\ttf Track} instance currently stored in the {\ttf nuSQUIDS} object.
  \item Get mixing angle
  \begin{lstlisting}
    double Get_MixingAngle(unsigned int i, unsigned int j) const;
  \end{lstlisting}
  Returns the $\theta_{i,j}$ mixing angle where {\ttf i} and {\ttf j} are zero based indexes.
  \item Get CP phase
  \begin{lstlisting}
    double Get_CPPhase(unsigned int i, unsigned int j) const;
  \end{lstlisting}
  Returns the $\delta_{i,j}$ CP phase where {\ttf i} and {\ttf j} are zero based indexes.
  \item Get square mass difference
  \begin{lstlisting}
    double Get_SquareMassDifference(unsigned int i) const;
  \end{lstlisting}
  Returns the $\Delta m^2_{i0}$ in ${\rm eV}^2$ where $1\le i < {\rm \tt numneu}$.
  \end{itemize}
  
\underline{\textbf{Functions set properties of the nuSQUIDS object as well as the state}}

\begin{itemize}
  \item Set {\ttfamily Body}
  \begin{lstlisting}
    void Set_Body(std::shared_ptr<Body>);
  \end{lstlisting}
  Sets the {\ttf Body} instance in which the neutrino propagation will take place.
  \item Set {\ttfamily Track}
  \begin{lstlisting}
    void Set_Track(std::shared_ptr<Track>);
  \end{lstlisting}
  Sets the {\ttf Track} instance which describes the neutrino propagation inside a
  given {\ttf Body}.
  \item Set the initial state
  \begin{lstlisting}
    void Set_initial_state(marray<double,1> state, Basis basis);
    void Set_initial_state(marray<double,2> state, Basis basis);
    void Set_initial_state(marray<double,3> state, Basis basis);
  \end{lstlisting}
  {\ttf Set\_initial\_state} sets the initial neutrino (and antineutrino) state. The states
  can be specified for the single and multiple energy modes can be specified using the 
  different {\ttf C++} signatures. In each case {\ttf basis} can be either {\ttf mass} or {\ttf flavor}.
  \begin{itemize}
  	\item {\ttf marray<double,1> state}: 
	Can only be used in single energy mode and is defined by 
	{\ttf state[$\alpha$]  = $\phi_\alpha$ } where $\alpha$ is a flavor or mass eigenstate index.
	\item {\ttf marray<double,2> state}: Can only be used in multiple energy mode and is defined
	by {\ttf state[ei][$\alpha$]  = $\phi_\alpha (E$[ei]$),$ } i.e. the flavor (mass) eigenstate composition at a given energy node {\ttf ei}.
	\item {\ttf marray<double,3> state}: Can only be used in multiple energy mode and is defined
	by {\ttf state[ei][$\rho$][$\alpha$]  = $\phi^{\rho}_\alpha (E$[ei]$),$ } i.e. the flavor (mass) eigenstate composition at a given energy node {\ttf ei}, and where $\rho = 0 \equiv {\rm neutrino}$ and $\rho = 0 \equiv {\rm antineutrino}$.
  \end{itemize}
  \item Set energy
  \begin{lstlisting}
    void Set_E(double enu);
  \end{lstlisting}
  Set the neutrino energy. This function can only be used in the single energy mode and
  {\ttf enu} has to be in natural units.
  \item Enable progress bar
  \begin{lstlisting}
    void Set_ProgressBar(bool opt);
  \end{lstlisting}
  If {\ttf opt} is {\ttf true} a progress bar will be printed to indicate the calculation progress.
  \item Enable tau regeneration
  \begin{lstlisting}
    void Set_TauRegeneration(bool opt);
  \end{lstlisting}
  If {\ttf opt} is {\ttf true}, {\ttf NT} is {\ttf both}, and non coherent interactions are enabled 
  tau regeneration effects will be included.
  \item Set mixing angle
  \begin{lstlisting}
    void Set_MixingAngle(unsigned int i, unsigned int j, double angle);
  \end{lstlisting}
  Sets the $\theta_{i,j}$ mixing angle to {\ttf angle}, where {\ttf i} and {\ttf j} are zero based indexes, and
  {\ttf angle} must be given in radians.
  \item Get CP phase
  \begin{lstlisting}
    void Set_CPPhase(unsigned int i, unsigned int j, doble phase);
  \end{lstlisting}
  Sets the $\delta_{i,j}$ CP phase to {\ttf phase}, where {\ttf i} and {\ttf j} are zero based indexes, and
  {\ttf phase} must be given in radians.
  \item Set square mass difference
  \begin{lstlisting}
    void Set_SquareMassDifference(unsigned int i, doble dmsq);
  \end{lstlisting}
  Sets the $\Delta m^2_{i0}$ to {\ttf dams}, given in ${\rm eV}^2$, where $1\le i < {\rm \tt numneu}$.
  \item Set parameters to default
  \begin{lstlisting}
    void Set_MixingParametersToDefault();
  \end{lstlisting}
  Sets the mixing angles and square mass mixings to the best fit point given in \citep{Gonzalez-Garcia:2014bfa}.
  \item Set the basis of solution
  \begin{lstlisting}
    void Set_Basis(Basis basis);
  \end{lstlisting}
  Sets the basis on which the evolution will be performed. Two options are available: {\ttf mass} and {\ttf interaction}, the 
  later being the default.
  \end{itemize}
  
\underline{\textbf{HDF5 interface functions}}
 
\begin{itemize}
  \item Serialize nuSQUIDS object into an HDF5 file.
  \begin{lstlisting}
    void WriteStateHDF5(std::string hdf5_filename,
                        std::string group = "/",
                        bool save_cross_sections = true, 
                        std::string cross_section_grp_loc = "") const;
  \end{lstlisting}
  Writes the current {\ttf nuSQUIDS} configuration and state into an HDF5 file
  for later use. {\ttf hdf5\_filename} specifies the output filename, {\ttf group} is the 
  location on the HDF5 structure where the {\ttf nuSQUIDS} object will be save; by default
  the root of the HDF5 will be used. Furthermore, {\ttf save\_cross\_sections} and {\ttf cross\_section\_grp\_loc}
  specify if cross sections will be saved and where on the HDF5 file structure. See Figure~\ref{fig:nusquids_hdf5}.
  \item Write the state into an HDF5 file.
  \begin{lstlisting}
    virtual void AddToWriteStateHDF5(hid_t hdf5_loc_id) const;
  \end{lstlisting}
  En ables the user to add content in the HDF5 file. An HDF5 location,{\ttf hdf5\_loc\_id}, is provided
  so the user can interface with the HDF5 library.
  \item Deserialize nuSQUIDS object into an HDF5 file.
  \begin{lstlisting}
    void ReadStateHDF5(std::string hdf5_filename,
                       std::string group = "/",
                       std::string cross_section_grp_loc = "");
  \end{lstlisting}
  Reads an previously generated HDF5 file and sets the {\ttf nuSQUIDS} object
  accordingly, i.e. it configures it and loads the saved state. {\ttf hdf5\_filename} specifies the input filename, {\ttf group} is the 
  location on the HDF5 structure where the {\ttf nuSQUIDS} object is; by default
  the root of the HDF5 is assumed. Furthermore, {\ttf cross\_section\_grp\_loc}
  specify where the cross sections are in the HDF5 file structure. See Figure~\ref{fig:nusquids_hdf5}.
  \item Read from an HDF5 file.
  \begin{lstlisting}
    virtual void AddToReadStateHDF5(hid_t hdf5_loc_id);
  \end{lstlisting}
  Enables the user to read user defined content from the HDF5 file. An HDF5 location,{\ttf hdf5\_loc\_id}, is provided
  so the user can interface with the HDF5 library.
\end{itemize}

\begin{figure}[htb]
\centering
\begin{tikzpicture}[%
  grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node {/}
    child { node [label=right:{{\ttf NeutrinoType}, number of flavors, interaction flag.}] {\ttf basic}}	
    child { node [label=right:{$\delta_{i,j} (rad).$}] {\ttf CPphases}}		
    child { node [label=right:{$\theta_{i,j} (rad).$}] {\ttf mixingangles}}
    child { node [label=right:{$\Delta m^2_{i,j} (\rm eV^2).$}] {\ttf massdifferences}}
    child { node [optional] {\ttf crosssections}
      child { node [label=right:{Neutrino charge current differential spectrum (${\rm GeV^{-1}}$).}]  {\ttf dNdEcc}}
      child { node [label=right:{Neutrino neutral current differential spectrum (${\rm GeV^{-1}}$).}] {\ttf dNdEnc}}
      child { node [label=right:{Tau decay lepton full spectrum (${\rm GeV^{-1}}$).}] {\ttf dNdEtauall}}
      child { node [label=right:{Tau decay lepton differential spectrum (${\rm GeV^{-1}}$).}] {\ttf dNdEtaulep}}
      child { node [label=right:{Tau decay length (${\rm cm^{-1}}$).}] {\ttf invlentau}}
      child { node [label=right:{Total neutral current neutrino cross section (${\rm cm^2}$).}]{\ttf sigmacc}}
      child { node [label=right:{Total charge current neutrino cross section (${\rm cm^2}$).}] {\ttf sigmanc}}
    }
    child [missing] {}				
    child [missing] {}				
    child [missing] {}
    child [missing] {}
    child [missing] {}			
    child [missing] {}
    child [missing] {}			
    child { node [label=right:{Energy nodes ({\rm eV}).}] {\ttf energies}}	
    child { node [label=right:{Flavor composition at each energy node.}] {\ttf flavorcomp}}
    child { node [label=right:{Mass composition at each energy node.}] {\ttf masscomp}}
    child { node [label=right:{Neutrino {\ttf SU\_vector} components at each energy node.}] {\ttf neustate}}
    child { node [label=right:{Antineutrino {\ttf SU\_vector} components at each energy node.}] {\ttf aneustate}}
    child { node [label=right:{body definition and parameters.}] {\ttf body}}
    child { node [label=right:{track definition and parameters.}] {\ttf track}}
    child { node [selected] {\ttf user\_parameters}}
    ;
\end{tikzpicture}
\caption{Structure of {\ttf nuSQUIDS} HDF5 file. The {\ttf crosssections} group will only be written when 
interactions are enable. Furthermore, {\ttf user\_parameters} are by default empty and can be set/access by {\ttf AddToWriteStateHDF5/AddToReadStateHDF5}.}
\label{fig:nusquids_hdf5}
\end{figure}
